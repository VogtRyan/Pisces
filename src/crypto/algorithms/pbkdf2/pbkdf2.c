/*
 * Copyright (c) 2008-2024 Ryan Vogt <rvogt.ca@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "pbkdf2.h"

#include "common/bytetype.h"
#include "common/errorflow.h"
#include "common/scrub.h"
#include "crypto/abstract/chf.h"
#include "crypto/algorithms/hmac/hmac.h"
#include "crypto/machine/endian.h"

#include <stddef.h>
#include <string.h>

/*
 * Allocate and initialize three HMAC contexts.
 *
 * The pwdOnly context will contain no data (only the password as the key will
 * be pre-processed). The pwdAndSalt context will have the key pre-processed,
 * and also have the salt data added to it.
 *
 * The prf context will be identical in state to the pwdAndSalt context, but be
 * a separate context.
 *
 * Return 0 on success or a negative value on error, specifically:
 * PBKDF2_ERROR_PASSWORD_TOO_LONG or PBKDF2_ERROR_SALT_TOO_LONG, with the
 * password error taking precedence.
 */
static int init_hmac_trio(const char *password, size_t passwordLen,
                          const byte_t *salt, size_t saltLen,
                          chf_algorithm_t alg, struct hmac_ctx **prf,
                          struct hmac_ctx **pwdOnly,
                          struct hmac_ctx **pwdAndSalt);

/*
 * Returns 1 if the requested key size would overflow the unsigned 32-bit
 * counter "i" in the PBKDF2 algorithm specification, prior to derivedKeyLen
 * bytes of key being derived. Returns 0 if the algorithm could derive enough
 * key material, either without overflowing or before overflowing the counter.
 */
static int would_overflow_counter_before_completion(size_t derivedKeyLen,
                                                    size_t hLen);

/*
 * Free the three contexts allocated by init_hmac_trio(). Any of the values of
 * *prf, *pwdOnly, and *pwdSalt may be NULL.
 */
static void free_hmac_trio(struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                           struct hmac_ctx **pwdAndSalt);

int pbkdf2_hmac(byte_t *derivedKey, size_t derivedKeyLen, const char *password,
                size_t passwordLen, const byte_t *salt, size_t saltLen,
                unsigned int iterationCount, chf_algorithm_t alg)
{
    struct hmac_ctx *prf = NULL;
    struct hmac_ctx *pwdOnly = NULL;
    struct hmac_ctx *pwdAndSalt = NULL;
    byte_t U[HMAC_MAX_DIGEST_BYTES];
    byte_t iMSOF[4];
    size_t octetsFromT, onOctet, hLen;
    unsigned int uMinusOne;
    uint32_t i;
    int initRet;
    int errVal = 0;

    ASSERT(iterationCount != 0, "PBKDF2 iteration count of zero");
    initRet = init_hmac_trio(password, passwordLen, salt, saltLen, alg, &prf,
                             &pwdOnly, &pwdAndSalt);
    if (initRet) {
        ERROR_CODE(isErr, errVal, initRet);
    }

    /*
     * Step one of the PBKDF2 algorithm verifies that the counter i will not
     * overflow in the loop below (unless, in an edge case, all of the key
     * material has already been derived).
     */
    hLen = hmac_digest_size(prf);
    if (would_overflow_counter_before_completion(derivedKeyLen, hLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_DERIVED_KEY_TOO_LONG);
    }

    /*
     * We generate a series of hLen-octet-long blocks, denoted as T_1, ...,
     * T_l. Each block T_i is generated by iterationCount > 0 cycles of HMAC
     * operations (yielding a number of bits equal to at most the output of the
     * HMAC digest). Each block is indexed by a 32-bit counter, i, ranging from
     * 1 to at most 2^{32}-1. No block may be indexed by i = 0.
     */
    i = 1;
    while (derivedKeyLen > 0 && i != 0) {

        /*
         * The number of octets we take from this T_i into the derived key is
         * bounded by the number produced by the HMAC.
         */
        octetsFromT = hLen < derivedKeyLen ? hLen : derivedKeyLen;

        /*
         * T_i = U_1 xor U_2 xor ... xor U_c.  First, compute U_1 into the U
         * array, and copy U_1 to the derived key location. Note that PRF at
         * this point has processed the password and the salt.
         */
        put_big_end_32(iMSOF, i);
        hmac_add(prf, iMSOF, 4);
        if (hmac_end(prf, U)) {
            /*
             * To the prf context, we added the salt then one 32-bit integer.
             * If this computation fails, it is because the salt is too long.
             */
            ERROR_CODE(isErr, errVal, PBKDF2_ERROR_SALT_TOO_LONG);
        }
        memcpy(derivedKey, U, octetsFromT);

        /*
         * Next, compute U_2, ..., U_c.  As each U_* value is computed and
         * stored back into the U array, xor it into the derived key, computing
         * T_i (or as much of it as we need) directly in place.
         */
        for (uMinusOne = 1; uMinusOne < iterationCount; uMinusOne++) {
            hmac_copy(prf, pwdOnly);
            hmac_add(prf, U, hLen);
            if (hmac_end(prf, U)) {
                /*
                 * To the prf context this time, we added only a single HMAC
                 * output, U_{uMinusOne}. This computation should never fail
                 * unless there is an error in the underlying HMAC library.
                 */
                FATAL_ERROR("PBKDF2 U_i HMAC computation failed for i > 1");
            }
            for (onOctet = 0; onOctet < octetsFromT; onOctet++) {
                derivedKey[onOctet] ^= U[onOctet];
            }
        }

        /* Move on to the next set of up to hLen octets in the derived key */
        derivedKey += octetsFromT;
        derivedKeyLen -= octetsFromT;

        /* Reset PRF for the next loop */
        hmac_copy(prf, pwdAndSalt);
        i++;
    }

    /*
     * The counter should never overflow prior to the full key being derived,
     * per the would_overflow_counter_before_completion() call above. That is,
     * the above loop should never break because i == 0, unless derivedKeyLen
     * is also 0.
     */
    ASSERT(derivedKeyLen == 0, "PBKDF2 loop counter overflow");

isErr:
    free_hmac_trio(&prf, &pwdOnly, &pwdAndSalt);
    scrub_memory(U, HMAC_MAX_DIGEST_BYTES);
    return errVal;
}

static int init_hmac_trio(const char *password, size_t passwordLen,
                          const byte_t *salt, size_t saltLen,
                          chf_algorithm_t alg, struct hmac_ctx **prf,
                          struct hmac_ctx **pwdOnly,
                          struct hmac_ctx **pwdAndSalt)
{
    int errVal = 0;

    *prf = hmac_alloc(alg);
    *pwdOnly = hmac_alloc(alg);
    *pwdAndSalt = hmac_alloc(alg);

    /*
     * Precompute two partial HMACs: an initialized HMAC that has processed no
     * data (just the password), and the same but that has processed the salt.
     */
    if (hmac_start(*prf, (const byte_t *)password, passwordLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_PASSWORD_TOO_LONG);
    }
    hmac_copy(*pwdOnly, *prf);

    if (hmac_add(*prf, salt, saltLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_SALT_TOO_LONG);
    }
    hmac_copy(*pwdAndSalt, *prf);

isErr:
    if (errVal) {
        free_hmac_trio(prf, pwdOnly, pwdAndSalt);
    }
    return errVal;
}

static int would_overflow_counter_before_completion(size_t derivedKeyLen,
                                                    size_t hLen)
{
    /*
     * Overflow will occur prior to deriving enough key material if:
     *   derivedKeyLen > (2^32-1) * hLen
     * That is true iff, with mathematical (not integer) division:
     *   derivedKeyLen / hLen > 2^32-1
     *
     * Note: the inequality check is against 2^32-1 (i.e., UINT32_MAX) instead
     * of against 2^32, because the counter can only take values from 1 to
     * 2^32-1 in the PBKDF2 specification (i.e., it can only take 2^32-1
     * possible values). PBKDF2 must not derive key material with the counter
     * set to 0.
     */
#if SIZE_MAX <= UINT32_MAX
    return 0;
#else
    size_t div = derivedKeyLen / hLen;
    if (derivedKeyLen % hLen == 0) {
        return div > (size_t)UINT32_MAX;
    }
    else {
        return div >= (size_t)UINT32_MAX;
    }
#endif
}

static void free_hmac_trio(struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                           struct hmac_ctx **pwdAndSalt)
{
    if (*prf != NULL) {
        hmac_free_scrub(*prf);
        *prf = NULL;
    }
    if (pwdOnly != NULL) {
        hmac_free_scrub(*pwdOnly);
        *pwdOnly = NULL;
    }
    if (*pwdAndSalt != NULL) {
        hmac_free_scrub(*pwdAndSalt);
        *pwdAndSalt = NULL;
    }
}
