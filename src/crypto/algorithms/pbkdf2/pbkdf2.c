/*
 * Copyright (c) 2008-2025 Ryan Vogt <rvogt.ca@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "pbkdf2.h"

#include "common/bytetype.h"
#include "common/errorflow.h"
#include "common/scrub.h"
#include "crypto/abstract/chf.h"
#include "crypto/algorithms/hmac/hmac.h"
#include "crypto/machine/endian.h"

#include <stddef.h>
#include <string.h>

/*
 * In pwdOnly, preprocess only the password (the key to the HMAC operations).
 * In both prf and pwdAndSalt, also preprocess the salt as the first part of
 * the message being authenticated.
 */
static int init_hmac_trio(const char *password, size_t passwordLen,
                          const byte *salt, size_t saltLen, chf_algorithm alg,
                          struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                          struct hmac_ctx **pwdAndSalt);
static void free_hmac_trio(struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                           struct hmac_ctx **pwdAndSalt);

static int would_overflow_counter_before_completion(size_t derivedKeyLen,
                                                    size_t hLen);

int pbkdf2_hmac(byte *derivedKey, size_t derivedKeyLen, const char *password,
                size_t passwordLen, const byte *salt, size_t saltLen,
                unsigned int iterationCount, chf_algorithm alg)
{
    struct hmac_ctx *prf = NULL;
    struct hmac_ctx *pwdOnly = NULL;
    struct hmac_ctx *pwdAndSalt = NULL;
    byte U[HMAC_MAX_DIGEST_SIZE];
    byte iMSOF[4];
    size_t octetsFromT, onOctet, hLen;
    unsigned int uMinusOne;
    uint32_t i;
    int res;
    int errVal = 0;

    ASSERT(iterationCount != 0, "PBKDF2 iteration count of zero");
    res = init_hmac_trio(password, passwordLen, salt, saltLen, alg, &prf,
                         &pwdOnly, &pwdAndSalt);
    if (res) {
        ERROR_CODE(isErr, errVal, res);
    }

    /*
     * Each block in the derived key is indexed by a 32-bit counter, i,
     * ranging from 1 to at most 2^32-1. Because no block may be indexed by
     * i == 0, the counter in general should not be allowed to overflow to 0.
     * The exception is the edge case in which the counter overflows to 0
     * immediately as the last of the key material is derived.
     */
    hLen = hmac_digest_size(prf);
    if (would_overflow_counter_before_completion(derivedKeyLen, hLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_DERIVED_KEY_TOO_LONG);
    }

    /*
     * Generate a series of blocks, each hLen octets long, denoted T_1, ...,
     * T_l. Each block T_i is generated by iterationCount > 0 cycles of HMAC
     * operations, and its length is the size of the HMAC digest.
     */
    i = 1;
    while (derivedKeyLen > 0 && i != 0) {
        /*
         * The check that i != 0 (verifying that the counter has not overflowed
         * while there is still key material to derive) should be unnecessary,
         * per the check in would_overflow_counter_before_completion(). But
         * having the i != 0 check in the loop condition lets us place an
         * assertion below this loop on the behaviour of
         * would_overflow_counter_before_completion().
         */

        octetsFromT = hLen < derivedKeyLen ? hLen : derivedKeyLen;

        /*
         * T_i = U_1 xor U_2 xor ... xor U_c. First, compute U_1 in the
         * derived key location.
         */
        put_big_end_32(iMSOF, i);
        hmac_add(prf, iMSOF, 4);
        if (hmac_end(prf, U)) {
            /*
             * To the prf context, we added the salt then one 32-bit integer.
             * If this computation fails, it is because the salt is too long.
             */
            ERROR_CODE(isErr, errVal, PBKDF2_ERROR_SALT_TOO_LONG);
        }
        memcpy(derivedKey, U, octetsFromT);

        /*
         * Next, compute U_2, ..., U_c.  As each U_* value is computed and
         * stored back into the U array, xor it into the derived key, computing
         * T_i (or as much of it as we need) directly in place.
         */
        for (uMinusOne = 1; uMinusOne < iterationCount; uMinusOne++) {
            hmac_copy(prf, pwdOnly);
            hmac_add(prf, U, hLen);
            res = hmac_end(prf, U);

            /*
             * To the prf context this time, we added only a single HMAC
             * output, U_{uMinusOne}. This computation should never fail on
             * account of the input being too large.
             */
            ASSERT(res == 0, "PBKDF2 U_i HMAC computation failed for i > 1");

            for (onOctet = 0; onOctet < octetsFromT; onOctet++) {
                derivedKey[onOctet] ^= U[onOctet];
            }
        }

        hmac_copy(prf, pwdAndSalt);
        derivedKey += octetsFromT;
        derivedKeyLen -= octetsFromT;
        i++;
    }

    /*
     * Per the check in would_overflow_counter_before_completion(), the above
     * loop should never break because i == 0, unless derivedKeyLen is also 0
     * (that is, the counter is only allowed to overflow in the edge case that
     * all of the key material has already been derived).
     */
    ASSERT(derivedKeyLen == 0, "PBKDF2 loop counter overflow");

isErr:
    free_hmac_trio(&prf, &pwdOnly, &pwdAndSalt);
    scrub_memory(U, HMAC_MAX_DIGEST_SIZE);
    return errVal;
}

static int init_hmac_trio(const char *password, size_t passwordLen,
                          const byte *salt, size_t saltLen, chf_algorithm alg,
                          struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                          struct hmac_ctx **pwdAndSalt)
{
    int errVal = 0;

    *prf = hmac_alloc(alg);
    *pwdOnly = hmac_alloc(alg);
    *pwdAndSalt = hmac_alloc(alg);

    if (hmac_start(*prf, (const byte *)password, passwordLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_PASSWORD_TOO_LONG);
    }
    hmac_copy(*pwdOnly, *prf);

    if (hmac_add(*prf, salt, saltLen)) {
        ERROR_CODE(isErr, errVal, PBKDF2_ERROR_SALT_TOO_LONG);
    }
    hmac_copy(*pwdAndSalt, *prf);

isErr:
    if (errVal) {
        free_hmac_trio(prf, pwdOnly, pwdAndSalt);
    }
    return errVal;
}

static void free_hmac_trio(struct hmac_ctx **prf, struct hmac_ctx **pwdOnly,
                           struct hmac_ctx **pwdAndSalt)
{
    if (*prf != NULL) {
        hmac_free_scrub(*prf);
        *prf = NULL;
    }
    if (pwdOnly != NULL) {
        hmac_free_scrub(*pwdOnly);
        *pwdOnly = NULL;
    }
    if (*pwdAndSalt != NULL) {
        hmac_free_scrub(*pwdAndSalt);
        *pwdAndSalt = NULL;
    }
}

static int would_overflow_counter_before_completion(size_t derivedKeyLen,
                                                    size_t hLen)
{
    /*
     * Overflow will occur prior to deriving enough key material if:
     *   derivedKeyLen > (2^32-1) * hLen
     * That is true iff, with mathematical (not integer) division:
     *   derivedKeyLen / hLen > 2^32-1
     *
     * The inequality check is against 2^32-1 (i.e., UINT32_MAX) instead of
     * against 2^32, because the counter can take 2^32-1 possible values (it
     * can take values from 1 to 2^32-1, but never 0).
     */
#if SIZE_MAX <= UINT32_MAX
    return 0;
#else
    size_t div = derivedKeyLen / hLen;
    if (derivedKeyLen % hLen == 0) {
        return div > (size_t)UINT32_MAX;
    }
    else {
        return div >= (size_t)UINT32_MAX;
    }
#endif
}
