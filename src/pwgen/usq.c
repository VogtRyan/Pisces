/*
 * Copyright (c) 2008-2025 Ryan Vogt <rvogt.ca@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "usq.h"

#include "common/bytetype.h"
#include "common/errorflow.h"
#include "common/scrub.h"
#include "crypto/abstract/cprng.h"

#include <math.h>
#include <stddef.h>

/*
 * Fills the result array with the requested number of unbiased characters from
 * the "simple" US QWERTY character set: uppercase and lowercase letters,
 * numbers, and symbols that can be typed using the shift key and a number key
 * (a simplified set of so-called special characters). Uses a pre-allocated
 * CPRNG.
 */
static void get_usq_simple_cprng(char *result, size_t num, struct cprng *rng);

/*
 * Checks if a password generated by get_usq_simple() contains all of an
 * uppercase letter, lowercase letter, number, and special character. Returns a
 * non-zero value if it contains all of these, otherwise returns 0.
 */
static int has_upper_lower_num_special(char *result, size_t num);

void get_usq_simple(char *result, size_t num)
{
    struct cprng *rng = cprng_alloc_default();
    get_usq_simple_cprng(result, num, rng);
    cprng_free_scrub(rng);
}

double bits_security_usq_simple(size_t num)
{
    /* log_2(72^n) == n * log_2(72) */
    return num * log2(72);
}

void get_usq_simple_enforced(char *result, size_t num)
{
    ASSERT(num >= 4, "An enforced password must have length of at least 4");

    struct cprng *rng = cprng_alloc_default();
    do {
        get_usq_simple_cprng(result, num, rng);
    } while (has_upper_lower_num_special(result, num) == 0);
    cprng_free_scrub(rng);
}

/*
 * Computing the number of bits of security for enforced passwords:
 *
 * Denote n = password length
 *
 * Define sets:
 *   P = capital letters (26)
 *   Q = lowercase letters (26)
 *   R = numbers (10)
 *   S = symbols (10)
 *
 * Number of USQ simple passwords, without any enforcement that they contain
 * one character from each set: 72^n
 *
 * Invalid passwords, because they lack characters from one set:
 *   Passwords without P = (72-26)^n = 46^n
 *   Passwords without Q = (72-26)^n = 46^n
 *   Passwords without R = (72-10)^n = 62^n
 *   Passwords without S = (72-10)^n = 62^n
 *   Total = 2*62^n + 2*46^n
 *
 * Invalid passwords, because they lack characters from two sets:
 *   Passwords without P/Q = (72-26-26)^n = 20^n
 *   Passwords without P/R = (72-26-10)^n = 36^n
 *   Passwords without P/S = (72-26-10)^n = 36^n
 *   Passwords without Q/R = (72-26-10)^n = 36^n
 *   Passwords without Q/S = (72-26-10)^n = 36^n
 *   Passwords without R/S = (72-10-10)^n = 52^n
 *   Total = 52^n + 4*36^n + 20^n
 *
 * Invalid passwords, because they lack characters from three sets:
 *   Passwords without P/Q/R = (72-26-26-10)^n = 10^n
 *   Passwords without P/Q/S = (72-26-26-10)^n = 10^n
 *   Passwords without P/R/S = (72-26-10-10)^n = 26^n
 *   Passwords without Q/R/S = (72-26-10-10)^n = 26^n
 *   Total = 2*26^n + 2*10^n
 *
 * Number of valid passwords, per the inclusion-exclusion principle:
 * v(n) = 72^n - (2*62^n + 2*46^n) + (52^n + 4*36^n + 20^n) - (2*26^n + 2*10^n)
 *      = 72^n - 2*62^n + 52^n - 2*46^n + 4*36^n - 2*26^n + 20^n - 2*10^n
 *
 * Computing log_2(v(n)) directly would be numerically unstable, so move into
 * log space.
 *
 * Denote each term of v(n) as a_i = (c_i) * (b_i)^n
 *   a_0 = ( 1) * (72)^n
 *   a_1 = (-2) * (62)^n
 *   [...]
 *   a_7 = (-2) * (10)^n
 *
 * Rewrite in log space: a_i = (c_i) * 2^(n * log_2(b_i))
 *   a_0 = ( 1) * 2^(n * log_2(72))
 *   a_1 = (-2) * 2^(n * log_2(62))
 *   [...]
 *   a_7 = (-2) * 2^(n * log_2(10))
 *
 * Denote each exponent as x_i:
 *   x_0 = n * log_2(72)
 *   x_1 = n * log_2(62)
 *   [...]
 *   x_7 = n * log_2(10)
 *
 * So, v(n) = sum_{i}[c_i * 2^(x_i)]
 *
 * Denote x_max = max(x_i) = n * log_2(72) = x_0
 *
 * Factor 2^(x_max) out of the sum:
 * v(n) = 2^{x_max} * sum_{i}[c_i * 2^(x_i - x_max)]
 *
 * Compute log_2(v(n)) from that expression of v(n):
 * log_2(v(n)) = log_2[2^(x_max) * sum_{i}[c_i * 2^(x_i - x_max)]]
 *             = log_2[2^(x_max)] + log_2[sum_{i}[c_i * 2^(x_i - x_max)]]]
 *             = x_max + log_2[sum_{i}[c_i * 2^(x_i - x_max)]]
 *             = x_0 + log_2[sum_{i}[c_i * 2^(x_i - x_0)]]
 */
double bits_security_usq_simple_enforced(size_t num)
{
    const double bases[] = {72, 62, 52, 46, 36, 26, 20, 10};
    const double coefficients[] = {1, -2, 1, -2, 4, -2, 1, -2};
    const size_t numBases = sizeof(bases) / sizeof(double);

    double x[numBases];
    double sum;
    size_t i;

    for (i = 0; i < numBases; i++) {
        x[i] = num * log2(bases[i]);
    }

    sum = 0.0;
    for (i = 0; i < numBases; i++) {
        sum += coefficients[i] * pow(2.0, x[i] - x[0]);
    }

    return x[0] + log2(sum);
}

static void get_usq_simple_cprng(char *result, size_t num, struct cprng *rng)
{
    byte_t *randArray = NULL;
    size_t remaining, toGenerate, i;

    /* Allocate a temporary array to store raw random bytes */
    remaining = num;
    randArray = (byte_t *)malloc(num);
    GUARD_ALLOC(randArray);

    /*
     * Generate random bytes and convert to characters.  Since there are 72
     * legal characters, we can use 72*3 = 216/256 possible values of a byte to
     * generate a character without biasing the password.
     */
    while (remaining > 0) {
        toGenerate = remaining;
        cprng_bytes(rng, randArray, toGenerate);
        for (i = 0; i < toGenerate; i++) {
            if (randArray[i] >= 216) {
                continue;
            }
            if (randArray[i] < 78) {
                /* Lower case letters */
                *result = (char)((int)randArray[i] % 26 + 97);
            }
            else if (randArray[i] < 156) {
                /* Upper case letters */
                *result = (char)((int)randArray[i] % 26 + 65);
            }
            else if (randArray[i] < 186) {
                /* Numbers */
                *result = (char)((int)randArray[i] % 10 + 48);
            }
            else if (randArray[i] < 189) {
                *result = '!';
            }
            else if (randArray[i] < 192) {
                *result = '@';
            }
            else if (randArray[i] < 195) {
                *result = '#';
            }
            else if (randArray[i] < 198) {
                *result = '$';
            }
            else if (randArray[i] < 201) {
                *result = '%';
            }
            else if (randArray[i] < 204) {
                *result = '^';
            }
            else if (randArray[i] < 207) {
                *result = '&';
            }
            else if (randArray[i] < 210) {
                *result = '*';
            }
            else if (randArray[i] < 213) {
                *result = '(';
            }
            else {
                *result = ')';
            }
            remaining--;
            result++;
        }
    }

    scrub_memory(randArray, num);
    free(randArray);
}

static int has_upper_lower_num_special(char *result, size_t num)
{
    int hasUpper = 0;
    int hasLower = 0;
    int hasNumber = 0;
    int hasSpecial = 0;
    size_t i;

    for (i = 0; i < num; i++) {
        if (*result >= (char)65 && *result <= (char)90) {
            hasUpper = 1;
        }
        else if (*result >= (char)97 && *result <= (char)122) {
            hasLower = 1;
        }
        else if (*result >= (char)48 && *result <= (char)57) {
            hasNumber = 1;
        }
        else {
            hasSpecial = 1;
        }
        result++;
    }

    return (hasUpper && hasLower && hasNumber && hasSpecial);
}
