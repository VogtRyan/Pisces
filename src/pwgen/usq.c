/*
 * Copyright (c) 2008-2023 Ryan Vogt <rvogt.ca@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "usq.h"

#include "common/bytetype.h"
#include "common/errorflow.h"
#include "common/scrub.h"
#include "crypto/abstract/cprng.h"

#include <stddef.h>

/*
 * Fills the result array with the requested number of unbiased characters from
 * the "simple" US QWERTY character set: uppercase and lowercase letters,
 * numbers, and symbols that can be typed using the shift key and a number key
 * (a simplified set of so-called special characters). Uses a pre-allocated
 * CPRNG.
 */
static void get_usq_simple_cprng(char *result, size_t num, struct cprng *rng);

/*
 * Checks if a password generated by get_usq_simple() contains all of an
 * uppercase letter, lowercase letter, number, and special character. Returns a
 * non-zero value if it contains all of these, otherwise returns 0.
 */
static int has_upper_lower_num_special(char *result, size_t num);

void get_usq_simple(char *result, size_t num)
{
    struct cprng *rng = cprng_alloc_default();
    get_usq_simple_cprng(result, num, rng);
    cprng_free_scrub(rng);
}

void get_usq_simple_enforced(char *result, size_t num)
{
    ASSERT(num >= 4, "An enforced password must have length of at least 4");

    struct cprng *rng = cprng_alloc_default();
    do {
        get_usq_simple_cprng(result, num, rng);
    } while (has_upper_lower_num_special(result, num) == 0);
    cprng_free_scrub(rng);
}

static void get_usq_simple_cprng(char *result, size_t num, struct cprng *rng)
{
    byte_t *randArray = NULL;
    size_t remaining, toGenerate, i;

    /* Allocate a temporary array to store raw random bytes */
    remaining = num;
    randArray = (byte_t *)malloc(num);
    ASSERT_ALLOC(randArray);

    /*
     * Generate random bytes and convert to characters.  Since there are 72
     * legal characters, we can use 72*3 = 216/256 possible values of a byte to
     * generate a character without biasing the password.
     */
    while (remaining > 0) {
        toGenerate = remaining;
        cprng_bytes(rng, randArray, toGenerate);
        for (i = 0; i < toGenerate; i++) {
            if (randArray[i] >= 216) {
                continue;
            }
            if (randArray[i] < 78) {
                /* Lower case letters */
                *result = (char)((int)randArray[i] % 26 + 97);
            }
            else if (randArray[i] < 156) {
                /* Upper case letters */
                *result = (char)((int)randArray[i] % 26 + 65);
            }
            else if (randArray[i] < 186) {
                /* Numbers */
                *result = (char)((int)randArray[i] % 10 + 48);
            }
            else if (randArray[i] < 189) {
                *result = '!';
            }
            else if (randArray[i] < 192) {
                *result = '@';
            }
            else if (randArray[i] < 195) {
                *result = '#';
            }
            else if (randArray[i] < 198) {
                *result = '$';
            }
            else if (randArray[i] < 201) {
                *result = '%';
            }
            else if (randArray[i] < 204) {
                *result = '^';
            }
            else if (randArray[i] < 207) {
                *result = '&';
            }
            else if (randArray[i] < 210) {
                *result = '*';
            }
            else if (randArray[i] < 213) {
                *result = '(';
            }
            else {
                *result = ')';
            }
            remaining--;
            result++;
        }
    }

    scrub_memory(randArray, num);
    free(randArray);
}

static int has_upper_lower_num_special(char *result, size_t num)
{
    int hasUpper = 0;
    int hasLower = 0;
    int hasNumber = 0;
    int hasSpecial = 0;
    size_t i;

    for (i = 0; i < num; i++) {
        if (*result >= (char)65 && *result <= (char)90) {
            hasUpper = 1;
        }
        else if (*result >= (char)97 && *result <= (char)122) {
            hasLower = 1;
        }
        else if (*result >= (char)48 && *result <= (char)57) {
            hasNumber = 1;
        }
        else {
            hasSpecial = 1;
        }
        result++;
    }

    return (hasUpper && hasLower && hasNumber && hasSpecial);
}
